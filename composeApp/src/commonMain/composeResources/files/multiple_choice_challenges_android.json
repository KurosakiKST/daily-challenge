[
  {
    "question": "Which component is responsible for providing a user interface in Android?",
    "options": [
      "Service",
      "BroadcastReceiver",
      "ContentProvider",
      "Activity"
    ],
    "correctAnswer": "Activity",
    "explanation": "An Activity in Android represents a single screen with a user interface.",
    "difficulty": "Easy"
  },
  {
    "question": "What is the purpose of ViewModel in Android Architecture Components?",
    "options": [
      "To display UI elements",
      "To hold UI-related data in a lifecycle-conscious way",
      "To observe LiveData changes",
      "To store database schema"
    ],
    "correctAnswer": "To hold UI-related data in a lifecycle-conscious way",
    "explanation": "ViewModel is designed to store and manage UI-related data while surviving configuration changes.",
    "difficulty": "Medium"
  },
  {
    "question": "Which Jetpack library is used to manage UI navigation within an Android app?",
    "options": [
      "Room",
      "LiveData",
      "Navigation",
      "DataStore"
    ],
    "correctAnswer": "Navigation",
    "explanation": "The Navigation component helps manage app navigation and back stack with a Navigation Graph.",
    "difficulty": "Medium"
  },
  {
    "question": "What is the function of the onCreate() method in an Android Activity?",
    "options": [
      "Initializes the database",
      "Starts the app",
      "Sets up the activity's initial state",
      "Handles user input"
    ],
    "correctAnswer": "Sets up the activity's initial state",
    "explanation": "onCreate() is called when the activity is first created and is used to initialize UI and components.",
    "difficulty": "Easy"
  },
  {
    "question": "What lifecycle method is called when an activity becomes visible to the user?",
    "options": [
      "onStop()",
      "onStart()",
      "onPause()",
      "onDestroy()"
    ],
    "correctAnswer": "onStart()",
    "explanation": "onStart() is called when the activity is becoming visible to the user.",
    "difficulty": "Easy"
  },
  {
    "question": "Which component is used to run background tasks even after the app is killed?",
    "options": [
      "Activity",
      "Fragment",
      "Service",
      "BroadcastReceiver"
    ],
    "correctAnswer": "Service",
    "explanation": "Services allow execution of tasks in the background, independent of user interaction.",
    "difficulty": "Medium"
  },
  {
    "question": "What does LiveData provide in Android?",
    "options": [
      "Persistent storage",
      "Background services",
      "Observable data holder",
      "UI rendering"
    ],
    "correctAnswer": "Observable data holder",
    "explanation": "LiveData is an observable data holder that respects lifecycle changes.",
    "difficulty": "Medium"
  },
  {
    "question": "What is Jetpack Compose?",
    "options": [
      "A testing library",
      "A navigation component",
      "A declarative UI toolkit",
      "A background service manager"
    ],
    "correctAnswer": "A declarative UI toolkit",
    "explanation": "Jetpack Compose is Android's modern toolkit for building native UIs declaratively.",
    "difficulty": "Medium"
  },
  {
    "question": "Which class is used to request runtime permissions?",
    "options": [
      "Intent",
      "ActivityCompat",
      "PermissionManager",
      "PermissionChecker"
    ],
    "correctAnswer": "ActivityCompat",
    "explanation": "ActivityCompat.requestPermissions() is used for requesting runtime permissions.",
    "difficulty": "Medium"
  },
  {
    "question": "Which database library is part of Jetpack?",
    "options": [
      "SQLite",
      "Room",
      "Realm",
      "Firebase"
    ],
    "correctAnswer": "Room",
    "explanation": "Room is a Jetpack library that provides an abstraction layer over SQLite.",
    "difficulty": "Medium"
  },
  {
    "question": "What is the function of the ViewBinding feature?",
    "options": [
      "Compiles layouts at runtime",
      "Generates binding classes for layouts",
      "Serializes data",
      "Manages navigation"
    ],
    "correctAnswer": "Generates binding classes for layouts",
    "explanation": "ViewBinding generates binding classes at compile time for each XML layout.",
    "difficulty": "Easy"
  },
  {
    "question": "Which Android manifest tag declares an app's entry point?",
    "options": [
      "<service>",
      "<activity>",
      "<intent-filter>",
      "<application>"
    ],
    "correctAnswer": "<intent-filter>",
    "explanation": "<intent-filter> with action MAIN and category LAUNCHER marks the entry point.",
    "difficulty": "Easy"
  },
  {
    "question": "What is the purpose of WorkManager?",
    "options": [
      "Schedule tasks that run immediately",
      "Handle UI transitions",
      "Manage foreground services",
      "Schedule deferrable background work"
    ],
    "correctAnswer": "Schedule deferrable background work",
    "explanation": "WorkManager is used for background tasks that should be guaranteed to execute.",
    "difficulty": "Medium"
  },
  {
    "question": "Which Android component is designed to handle asynchronous broadcasts?",
    "options": [
      "Service",
      "BroadcastReceiver",
      "Activity",
      "ContentProvider"
    ],
    "correctAnswer": "BroadcastReceiver",
    "explanation": "BroadcastReceiver is used to respond to system-wide broadcast announcements.",
    "difficulty": "Medium"
  },
  {
    "question": "Which class is used to start a new activity?",
    "options": [
      "Context",
      "Intent",
      "ViewModel",
      "Fragment"
    ],
    "correctAnswer": "Intent",
    "explanation": "Intent is a messaging object used to request an action from another app component.",
    "difficulty": "Easy"
  },
  {
    "question": "What is the use of the Navigation Graph in Jetpack Navigation Component?",
    "options": [
      "Manage UI styles",
      "Manage dependencies",
      "Define all navigation paths",
      "Define database schema"
    ],
    "correctAnswer": "Define all navigation paths",
    "explanation": "The Navigation Graph is an XML resource that defines all the navigation paths and destinations within an app.",
    "difficulty": "Medium"
  },
  {
    "question": "What is the main advantage of using Kotlin over Java for Android development?",
    "options": [
      "More verbose syntax",
      "No support for coroutines",
      "Better null safety and concise syntax",
      "Slower performance"
    ],
    "correctAnswer": "Better null safety and concise syntax",
    "explanation": "Kotlin offers concise syntax, improved type-safety, and null-safety compared to Java.",
    "difficulty": "Easy"
  },
  {
    "question": "Which Android component is used for persistent key-value storage?",
    "options": [
      "Room",
      "SharedPreferences",
      "DataStore",
      "Bundle"
    ],
    "correctAnswer": "SharedPreferences",
    "explanation": "SharedPreferences is used to store primitive data in key-value pairs.",
    "difficulty": "Easy"
  },
  {
    "question": "Which of the following is NOT a valid Android app component?",
    "options": [
      "Service",
      "ContentProvider",
      "Intent",
      "Activity"
    ],
    "correctAnswer": "Intent",
    "explanation": "Intent is not a component, but a messaging object. The main components are Activity, Service, BroadcastReceiver, and ContentProvider.",
    "difficulty": "Medium"
  },
  {
    "question": "What does the keyword 'lateinit' mean in Kotlin?",
    "options": [
      "Initializes variable at compile time",
      "Declares a nullable type",
      "Declares a variable that will be initialized later",
      "Initializes variable in constructor only"
    ],
    "correctAnswer": "Declares a variable that will be initialized later",
    "explanation": "lateinit allows you to declare a non-null variable that will be initialized later.",
    "difficulty": "Medium"
  },
  {
    "question": "Which tool converts XML layout to Kotlin/Java objects?",
    "options": [
      "RecyclerView",
      "ViewBinding",
      "LiveData",
      "Room"
    ],
    "correctAnswer": "ViewBinding",
    "explanation": "ViewBinding generates a binding class for each XML layout, providing type-safe access to views.",
    "difficulty": "Easy"
  },
  {
    "question": "What annotation is used to denote a Room entity?",
    "options": [
      "@Database",
      "@Dao",
      "@Entity",
      "@ColumnInfo"
    ],
    "correctAnswer": "@Entity",
    "explanation": "@Entity annotation is used to define a data class as a table in Room database.",
    "difficulty": "Medium"
  },
  {
    "question": "What does the term 'recomposition' refer to in Jetpack Compose?",
    "options": [
      "Redrawing XML layouts",
      "Recalculating LiveData",
      "Updating the UI when state changes",
      "Restarting the app"
    ],
    "correctAnswer": "Updating the UI when state changes",
    "explanation": "Recomposition in Compose is the process of updating the UI automatically when state changes.",
    "difficulty": "Medium"
  },
  {
    "question": "What is the purpose of the 'onSaveInstanceState()' method in Android?",
    "options": [
      "To restart the app",
      "To save UI state before the app is killed",
      "To pause background services",
      "To restore permissions"
    ],
    "correctAnswer": "To save UI state before the app is killed",
    "explanation": "onSaveInstanceState() is called before an activity may be killed so that the state can be saved and restored later.",
    "difficulty": "Medium"
  },
  {
    "question": "Which class provides backward-compatible features on older Android versions?",
    "options": [
      "ActivityCompat",
      "AppCompatActivity",
      "SupportFragment",
      "ContextWrapper"
    ],
    "correctAnswer": "AppCompatActivity",
    "explanation": "AppCompatActivity is part of the AppCompat library and allows the use of newer features on older Android versions.",
    "difficulty": "Medium"
  },
  {
    "question": "What does 'sealed class' mean in Kotlin?",
    "options": [
      "Class that can be inherited from any package",
      "Class with private constructor only",
      "Class with limited subclasses in the same file",
      "Class with no constructor"
    ],
    "correctAnswer": "Class with limited subclasses in the same file",
    "explanation": "A sealed class restricts subclassing to only within the same file, useful for representing restricted class hierarchies.",
    "difficulty": "Medium"
  },
  {
    "question": "What is the lifecycle-aware component that survives configuration changes?",
    "options": [
      "Fragment",
      "LiveData",
      "ViewModel",
      "BroadcastReceiver"
    ],
    "correctAnswer": "ViewModel",
    "explanation": "ViewModel holds UI-related data and survives configuration changes such as screen rotations.",
    "difficulty": "Medium"
  },
  {
    "question": "Which layout arranges its children in a single direction, either vertically or horizontally?",
    "options": [
      "ConstraintLayout",
      "FrameLayout",
      "LinearLayout",
      "RelativeLayout"
    ],
    "correctAnswer": "LinearLayout",
    "explanation": "LinearLayout places its children in a single row or column based on the orientation.",
    "difficulty": "Easy"
  },
  {
    "question": "What is the correct use of 'by lazy' in Kotlin?",
    "options": [
      "To define a global variable",
      "To define a nullable variable",
      "To initialize a value only when accessed",
      "To call suspend functions"
    ],
    "correctAnswer": "To initialize a value only when accessed",
    "explanation": "The 'by lazy' delegate initializes the value only when it's accessed for the first time.",
    "difficulty": "Medium"
  },
  {
    "question": "Which Compose function is used to make a state observable?",
    "options": [
      "rememberMutableStateOf()",
      "observeState()",
      "mutableStateOf()",
      "observeAsState()"
    ],
    "correctAnswer": "mutableStateOf()",
    "explanation": "mutableStateOf() is used in Jetpack Compose to create observable state variables.",
    "difficulty": "Medium"
  },
  {
    "question": "Which permission is needed to access the user's location in Android?",
    "options": [
      "android.permission.ACCESS_WIFI_STATE",
      "android.permission.INTERNET",
      "android.permission.ACCESS_FINE_LOCATION",
      "android.permission.READ_CONTACTS"
    ],
    "correctAnswer": "android.permission.ACCESS_FINE_LOCATION",
    "explanation": "ACCESS_FINE_LOCATION is used for precise location access in Android.",
    "difficulty": "Easy"
  },
  {
    "question": "Which operator is used for safe calls in Kotlin?",
    "options": [
      "?=",
      "!!",
      "?",
      "?."
    ],
    "correctAnswer": "?.",
    "explanation": "The safe call operator '?.' allows you to safely access properties and methods on nullable types.",
    "difficulty": "Easy"
  },
  {
    "question": "What is the benefit of using Coroutines in Android?",
    "options": [
      "It makes XML layouts easier to write",
      "It improves activity startup time",
      "It provides a simpler way to handle background tasks",
      "It increases APK size"
    ],
    "correctAnswer": "It provides a simpler way to handle background tasks",
    "explanation": "Coroutines simplify asynchronous programming by providing a structured and concise way to run tasks in the background.",
    "difficulty": "Medium"
  },
  {
    "question": "Which function in Compose is used to declare a Composable UI?",
    "options": [
      "fun Compose()",
      "@Composable fun",
      "@Composable val",
      "layout {}"
    ],
    "correctAnswer": "@Composable fun",
    "explanation": "@Composable is an annotation that marks a function as composable for Jetpack Compose UI.",
    "difficulty": "Medium"
  },
  {
    "question": "Which lifecycle method is called just before an activity is destroyed?",
    "options": [
      "onStop()",
      "onPause()",
      "onDestroy()",
      "onRestart()"
    ],
    "correctAnswer": "onDestroy()",
    "explanation": "onDestroy() is called before the activity is destroyed, allowing cleanup of resources.",
    "difficulty": "Easy"
  },
  {
    "question": "In Kotlin, what does 'val' declare?",
    "options": [
      "A variable that can be reassigned",
      "A mutable reference",
      "An immutable read-only reference",
      "A nullable variable"
    ],
    "correctAnswer": "An immutable read-only reference",
    "explanation": "'val' declares a variable whose reference cannot be changed after initialization.",
    "difficulty": "Easy"
  },
  {
    "question": "Which of these is not a Coroutine dispatcher?",
    "options": [
      "Dispatchers.Main",
      "Dispatchers.IO",
      "Dispatchers.Default",
      "Dispatchers.XML"
    ],
    "correctAnswer": "Dispatchers.XML",
    "explanation": "Dispatchers.XML does not exist. The standard coroutine dispatchers include Main, IO, Default, and Unconfined.",
    "difficulty": "Medium"
  },
  {
    "question": "What is the default thread for LiveData observers?",
    "options": [
      "IO thread",
      "Main thread",
      "Worker thread",
      "UI thread"
    ],
    "correctAnswer": "Main thread",
    "explanation": "LiveData notifies observers on the main thread to safely update UI components.",
    "difficulty": "Medium"
  },
  {
    "question": "Which Compose component is used to create scrollable content?",
    "options": [
      "Column",
      "LazyRow",
      "Box",
      "LazyColumn"
    ],
    "correctAnswer": "LazyColumn",
    "explanation": "LazyColumn efficiently creates vertically scrollable lists in Jetpack Compose.",
    "difficulty": "Medium"
  },
  {
    "question": "What is the purpose of the 'suspend' keyword in Kotlin?",
    "options": [
      "To create a static method",
      "To stop a function immediately",
      "To indicate the function can be paused and resumed",
      "To handle exceptions"
    ],
    "correctAnswer": "To indicate the function can be paused and resumed",
    "explanation": "The 'suspend' modifier marks a function that can be suspended and resumed in a coroutine.",
    "difficulty": "Medium"
  },
  {
    "question": "Which class is used to display simple messages in a popup?",
    "options": [
      "AlertDialog",
      "Snackbar",
      "Toast",
      "DialogFragment"
    ],
    "correctAnswer": "Toast",
    "explanation": "Toast is used to show brief messages that disappear automatically after a short duration.",
    "difficulty": "Easy"
  },
  {
    "question": "What type of architecture does MVVM stand for?",
    "options": [
      "Model-View-Model-View",
      "Model-View-ViewModel",
      "Model-Variable-ViewModel",
      "Model-Validator-View"
    ],
    "correctAnswer": "Model-View-ViewModel",
    "explanation": "MVVM separates the UI (View), data (Model), and logic (ViewModel) to improve code maintainability.",
    "difficulty": "Medium"
  },
  {
    "question": "Which Jetpack library replaces SharedPreferences for key-value storage?",
    "options": [
      "DataStore",
      "Room",
      "LiveData",
      "ViewModel"
    ],
    "correctAnswer": "DataStore",
    "explanation": "DataStore is a Jetpack library that provides a more robust and asynchronous approach to key-value storage.",
    "difficulty": "Medium"
  },
  {
    "question": "Which annotation is used to mark a Composable preview in Jetpack Compose?",
    "options": [
      "@Previewable",
      "@ComposablePreview",
      "@Preview",
      "@ViewPreview"
    ],
    "correctAnswer": "@Preview",
    "explanation": "@Preview is used to render a composable function in the Android Studio preview pane.",
    "difficulty": "Easy"
  },
  {
    "question": "What is the purpose of 'remember' in Jetpack Compose?",
    "options": [
      "To store a value in a Bundle",
      "To track view state across recompositions",
      "To persist data in local storage",
      "To cache images"
    ],
    "correctAnswer": "To track view state across recompositions",
    "explanation": "'remember' stores values across recompositions to maintain state during UI updates.",
    "difficulty": "Medium"
  },
  {
    "question": "What is the function of 'LaunchedEffect' in Jetpack Compose?",
    "options": [
      "To launch a coroutine tied to the lifecycle of a Composable",
      "To start a new Activity",
      "To load images asynchronously",
      "To inflate XML layouts"
    ],
    "correctAnswer": "To launch a coroutine tied to the lifecycle of a Composable",
    "explanation": "LaunchedEffect runs a suspend function when the key changes, within the Composable’s lifecycle.",
    "difficulty": "Hard"
  },
  {
    "question": "Which modifier is used in Compose to make an element clickable?",
    "options": [
      "pointerInput",
      "onClickModifier",
      "clickable",
      "gestureDetector"
    ],
    "correctAnswer": "clickable",
    "explanation": "The 'clickable' modifier makes a Composable respond to click gestures.",
    "difficulty": "Easy"
  }
]

