[
  {
    "question": "What keyword is used to declare an immutable variable in Kotlin?",
    "options": [
      "var",
      "val",
      "const",
      "let"
    ],
    "correctAnswer": "val",
    "explanation": "In Kotlin, `val` is used to declare read-only (immutable) variables, while `var` is used for mutable variables.",
    "difficulty": "Easy"
  },
  {
    "question": "Which of the following is true about Kotlin's null safety?",
    "options": [
      "All types are nullable by default.",
      "NullPointerExceptions are impossible.",
      "Types are non-nullable by default.",
      "The '??' operator is used for safe calls."
    ],
    "correctAnswer": "Types are non-nullable by default.",
    "explanation": "Kotlin's type system distinguishes between nullable (e.g., `String?`) and non-nullable (e.g., `String`) types to prevent NullPointerExceptions at compile time.",
    "difficulty": "Easy"
  },
  {
    "question": "How do you define a function in Kotlin?",
    "options": [
      "function myFunction() {}",
      "def myFunction() {}",
      "fun myFunction() {}",
      "void myFunction() {}"
    ],
    "correctAnswer": "fun myFunction() {}",
    "explanation": "The `fun` keyword is used to declare a function in Kotlin.",
    "difficulty": "Easy"
  },
  {
    "question": "What is the entry point for a Kotlin application?",
    "options": [
      "start()",
      "main()",
      "run()",
      "AppMain()"
    ],
    "correctAnswer": "main()",
    "explanation": "The `main` function is the entry point for Kotlin applications, similar to Java and C++.",
    "difficulty": "Easy"
  },
  {
    "question": "Which scope function is used to execute a block of code on a non-null object and returns the lambda result?",
    "options": [
      "apply",
      "also",
      "let",
      "run"
    ],
    "correctAnswer": "let",
    "explanation": "`let` is often used for executing a code block only if a value is not null and returns the result of the lambda.",
    "difficulty": "Medium"
  },
  {
    "question": "What is a data class in Kotlin primarily used for?",
    "options": [
      "Performing complex calculations.",
      "Handling UI interactions.",
      "Holding data/state.",
      "Managing network requests."
    ],
    "correctAnswer": "Holding data/state.",
    "explanation": "Data classes automatically generate `equals()`, `hashCode()`, `toString()`, `copy()`, and component functions, making them ideal for classes that primarily hold data.",
    "difficulty": "Easy"
  },
  {
    "question": "Which keyword is used to inherit a class in Kotlin?",
    "options": [
      "extends",
      "implements",
      ":",
      "inherits"
    ],
    "correctAnswer": ":",
    "explanation": "In Kotlin, a colon `:` is used after the class name to denote inheritance or interface implementation.",
    "difficulty": "Easy"
  },
  {
    "question": "What are extension functions in Kotlin?",
    "options": [
      "Functions that can only be defined inside a class.",
      "Functions that allow adding new functionality to existing classes without modifying their source code.",
      "Functions that extend the maximum number of parameters allowed.",
      "Built-in Kotlin standard library functions."
    ],
    "correctAnswer": "Functions that allow adding new functionality to existing classes without modifying their source code.",
    "explanation": "Extension functions provide a way to 'add' methods to classes you don't own or cannot modify directly.",
    "difficulty": "Medium"
  },
  {
    "question": "How do you declare a nullable String variable in Kotlin?",
    "options": [
      "var name: String = null",
      "var name: String?",
      "var name: Nullable<String>",
      "var name? : String"
    ],
    "correctAnswer": "var name: String?",
    "explanation": "A question mark `?` after the type (e.g., `String?`) indicates that the variable can hold a null value.",
    "difficulty": "Easy"
  },
  {
    "question": "What does the `when` expression in Kotlin replace from Java?",
    "options": [
      "if-else if-else",
      "for loop",
      "switch statement",
      "try-catch block"
    ],
    "correctAnswer": "switch statement",
    "explanation": "`when` is Kotlin's more powerful and flexible version of Java's `switch` statement.",
    "difficulty": "Easy"
  },
  {
    "question": "What is the default visibility modifier in Kotlin if none is specified?",
    "options": [
      "private",
      "protected",
      "internal",
      "public"
    ],
    "correctAnswer": "public",
    "explanation": "If no visibility modifier is specified, the declaration is `public` by default in Kotlin.",
    "difficulty": "Medium"
  },
  {
    "question": "Which coroutine builder is used for launching a new coroutine that does not return a result?",
    "options": [
      "async",
      "runBlocking",
      "launch",
      "withContext"
    ],
    "correctAnswer": "launch",
    "explanation": "`launch` is a fire-and-forget coroutine builder. It starts a new coroutine and doesn't return its result.",
    "difficulty": "Medium"
  },
  {
    "question": "What is the purpose of the `lateinit` keyword in Kotlin?",
    "options": [
      "To declare a variable that will be initialized lazily.",
      "To declare a non-null type property that will be initialized later.",
      "To declare a nullable variable.",
      "To declare a constant."
    ],
    "correctAnswer": "To declare a non-null type property that will be initialized later.",
    "explanation": "`lateinit` is used for non-null properties that are initialized after the object's construction (e.g., through dependency injection or in a setup method).",
    "difficulty": "Medium"
  },
  {
    "question": "How can you create a singleton object in Kotlin?",
    "options": [
      "Using the `singleton` keyword.",
      "Using the `object` keyword.",
      "Using a private constructor and a static instance.",
      "Using the `@Singleton` annotation."
    ],
    "correctAnswer": "Using the `object` keyword.",
    "explanation": "Declaring an `object` in Kotlin creates a singleton instance automatically.",
    "difficulty": "Medium"
  },
  {
    "question": "What is the Elvis operator in Kotlin?",
    "options": [
      "?.",
      "!!",
      "?:",
      "?."
    ],
    "correctAnswer": "?:",
    "explanation": "The Elvis operator `?:` provides a default value if an expression is null. `val length = name?.length ?: -1`",
    "difficulty": "Medium"
  },
  {
    "question": "Which of these is NOT a basic data type in Kotlin?",
    "options": [
      "Int",
      "Float",
      "Boolean",
      "ArrayList"
    ],
    "correctAnswer": "ArrayList",
    "explanation": "Int, Float, and Boolean are basic data types. ArrayList is a collection type.",
    "difficulty": "Easy"
  },
  {
    "question": "What is a lambda expression in Kotlin?",
    "options": [
      "A way to define a class anonymously.",
      "A function that is passed as an argument to another function.",
      "An anonymous function that can be treated as a value.",
      "A special type of comment."
    ],
    "correctAnswer": "An anonymous function that can be treated as a value.",
    "explanation": "Lambdas are short blocks of code that can be passed around as arguments, returned, or stored in variables.",
    "difficulty": "Medium"
  },
  {
    "question": "Which keyword is used to define a primary constructor in a Kotlin class?",
    "options": [
      "init",
      "constructor",
      "No explicit keyword, it's part of the class header",
      "primaryConstructor"
    ],
    "correctAnswer": "No explicit keyword, it's part of the class header",
    "explanation": "The primary constructor is declared directly in the class header: `class Person(val name: String)`.",
    "difficulty": "Medium"
  },
  {
    "question": "What does the `open` keyword signify on a class in Kotlin?",
    "options": [
      "The class is abstract.",
      "The class can be inherited from.",
      "The class is publicly accessible.",
      "The class can be instantiated."
    ],
    "correctAnswer": "The class can be inherited from.",
    "explanation": "By default, Kotlin classes are `final`. The `open` keyword allows them to be subclassed.",
    "difficulty": "Medium"
  },
  {
    "question": "Which scope function's primary purpose is to configure an object and return the object itself, using `this` as the context object?",
    "options": [
      "let",
      "run",
      "with",
      "apply"
    ],
    "correctAnswer": "apply",
    "explanation": "`apply` executes a block of code on an object (`this` refers to the object) and returns the object itself. It's useful for object initialization.",
    "difficulty": "Medium"
  },
  {
    "question": "How do you perform a type check in Kotlin?",
    "options": [
      "instanceof",
      "typeof",
      "is",
      "as"
    ],
    "correctAnswer": "is",
    "explanation": "The `is` operator checks if an object is an instance of a particular type, and `!is` is its negation.",
    "difficulty": "Easy"
  },
  {
    "question": "What is a `companion object` in Kotlin?",
    "options": [
      "An object that is created every time its containing class is instantiated.",
      "A way to define static members for a class.",
      "An object used for debugging purposes only.",
      "A synonym for a data class."
    ],
    "correctAnswer": "A way to define static members for a class.",
    "explanation": "A `companion object` is a singleton object tied to a class, allowing access to its members via the class name, similar to static members in Java.",
    "difficulty": "Medium"
  },
  {
    "question": "Which of the following creates an immutable list in Kotlin?",
    "options": [
      "arrayListOf()",
      "mutableListOf()",
      "listOf()",
      "LinkedList()"
    ],
    "correctAnswer": "listOf()",
    "explanation": "`listOf()` creates a read-only (immutable) list, while `mutableListOf()` creates a mutable list.",
    "difficulty": "Easy"
  },
  {
    "question": "What does the `!!` operator do in Kotlin?",
    "options": [
      "It performs a safe call.",
      "It asserts that an expression is not null and throws a NullPointerException if it is.",
      "It provides a default value if an expression is null.",
      "It converts a nullable type to a non-nullable type safely."
    ],
    "correctAnswer": "It asserts that an expression is not null and throws a NullPointerException if it is.",
    "explanation": "The not-null assertion operator (`!!`) converts any value to a non-null type and throws an exception if the value is null.",
    "difficulty": "Medium"
  },
  {
    "question": "How are string templates used in Kotlin?",
    "options": [
      "By using the `+` operator to concatenate strings and variables.",
      "By prefixing variable names with `$` within a string literal.",
      "By using the `String.format()` method only.",
      "String templates are not supported in Kotlin."
    ],
    "correctAnswer": "By prefixing variable names with `$` within a string literal.",
    "explanation": "Kotlin supports string templates, e.g., `val name = \"World\"; println(\"Hello, $name!\")` or `println(\"Text ${obj.property}\")`.",
    "difficulty": "Easy"
  },
  {
    "question": "What is the purpose of a `sealed class` in Kotlin?",
    "options": [
      "To prevent any class from inheriting from it.",
      "To restrict the class hierarchy, where all subclasses must be known at compile time and declared in the same file or a nested class.",
      "To create a class that can only be instantiated once.",
      "To automatically seal all methods from being overridden."
    ],
    "correctAnswer": "To restrict the class hierarchy, where all subclasses must be known at compile time and declared in the same file or a nested class.",
    "explanation": "Sealed classes are used to represent restricted class hierarchies, providing more control over inheritance, often used with `when` expressions for exhaustive checks.",
    "difficulty": "Hard"
  },
  {
    "question": "Which keyword is used to handle exceptions in Kotlin?",
    "options": [
      "catch",
      "throws",
      "try",
      "except"
    ],
    "correctAnswer": "try",
    "explanation": "Kotlin uses `try-catch-finally` blocks for exception handling, similar to Java. The `try` keyword initiates the block.",
    "difficulty": "Easy"
  },
  {
    "question": "What is the `Unit` return type in Kotlin equivalent to in Java?",
    "options": [
      "null",
      "Object",
      "void",
      "Nothing"
    ],
    "correctAnswer": "void",
    "explanation": "`Unit` in Kotlin is similar to `void` in Java. It indicates that a function does not return any meaningful value.",
    "difficulty": "Easy"
  },
  {
    "question": "How do you declare an array of integers in Kotlin?",
    "options": [
      "var nums: Array<Int> = arrayOf(1, 2, 3)",
      "var nums: Int[] = {1, 2, 3}",
      "var nums: List<Int> = [1, 2, 3]",
      "var nums = new IntArray(1, 2, 3)"
    ],
    "correctAnswer": "var nums: Array<Int> = arrayOf(1, 2, 3)",
    "explanation": "`arrayOf()` is a library function to create an array. For primitive types, specialized arrays like `intArrayOf()` also exist.",
    "difficulty": "Easy"
  },
  {
    "question": "What does the `internal` visibility modifier mean?",
    "options": [
      "Visible only within the same class.",
      "Visible only within the same file.",
      "Visible anywhere within the same module.",
      "Visible only within the same package."
    ],
    "correctAnswer": "Visible anywhere within the same module.",
    "explanation": "`internal` declarations are visible within the same compilation module (e.g., a Gradle project, IntelliJ IDEA module).",
    "difficulty": "Medium"
  },
  {
    "question": "Which coroutine builder is used to launch a new coroutine that returns a result (a `Deferred` value)?",
    "options": [
      "launch",
      "async",
      "runBlocking",
      "withContext"
    ],
    "correctAnswer": "async",
    "explanation": "`async` starts a new coroutine and returns a `Deferred` object, which will eventually contain the result of the coroutine's computation.",
    "difficulty": "Medium"
  },
  {
    "question": "What is the primary advantage of using `lazy` delegate in Kotlin?",
    "options": [
      "It ensures the property is initialized before its first access.",
      "It allows a non-null property to be initialized later.",
      "It initializes the property only upon its first access, saving resources if the property is not used.",
      "It makes the property thread-safe by default."
    ],
    "correctAnswer": "It initializes the property only upon its first access, saving resources if the property is not used.",
    "explanation": "Lazy initialization means the value of the property is computed only when it's accessed for the first time. The result is then cached.",
    "difficulty": "Medium"
  },
  {
    "question": "How do you make a Kotlin class implement an interface?",
    "options": [
      "class MyClass extends MyInterface {}",
      "class MyClass implements MyInterface {}",
      "class MyClass : MyInterface {}",
      "class MyClass inherits MyInterface {}"
    ],
    "correctAnswer": "class MyClass : MyInterface {}",
    "explanation": "A colon `:` is used followed by the interface name. If a class inherits from another class and implements interfaces, the superclass comes first.",
    "difficulty": "Easy"
  },
  {
    "question": "What is the purpose of the `in` keyword when used with generics (e.g., `in T`)?",
    "options": [
      "It makes the type parameter covariant (can be a producer).",
      "It makes the type parameter contravariant (can be a consumer).",
      "It restricts the type parameter to be non-nullable.",
      "It allows the type parameter to be used for input and output."
    ],
    "correctAnswer": "It makes the type parameter contravariant (can be a consumer).",
    "explanation": "`in` marks a type parameter as contravariant, meaning it can only be consumed (passed as an argument) and not produced (returned).",
    "difficulty": "Hard"
  },
  {
    "question": "What is the `it` keyword used for in Kotlin lambdas?",
    "options": [
      "It refers to the `this` instance of the enclosing class.",
      "It is a keyword to iterate over collections.",
      "It is an implicit name for a single parameter in a lambda expression.",
      "It is used to denote an immutable variable within a lambda."
    ],
    "correctAnswer": "It is an implicit name for a single parameter in a lambda expression.",
    "explanation": "If a lambda has only one parameter, Kotlin allows you to refer to it using the implicit name `it`.",
    "difficulty": "Easy"
  },
  {
    "question": "Which collection type in Kotlin stores elements in a specific order and allows duplicates?",
    "options": [
      "Set",
      "Map",
      "List",
      "Array"
    ],
    "correctAnswer": "List",
    "explanation": "A `List` is an ordered collection of items that can contain duplicate elements.",
    "difficulty": "Easy"
  },
  {
    "question": "What is the primary function of `runBlocking` in Kotlin Coroutines?",
    "options": [
      "To launch a new coroutine asynchronously.",
      "To bridge blocking code to suspending code, typically used in `main` functions or tests.",
      "To switch the context of a coroutine.",
      "To cancel a running coroutine."
    ],
    "correctAnswer": "To bridge blocking code to suspending code, typically used in `main` functions or tests.",
    "explanation": "`runBlocking` blocks the current thread until the coroutine it launches completes. It's mainly for integration with blocking code.",
    "difficulty": "Medium"
  },
  {
    "question": "How can you define an extension property in Kotlin?",
    "options": [
      "fun String.newProperty: Int = this.length",
      "val String.newProperty: Int get() = this.length",
      "property String.newProperty: Int = this.length",
      "extend String.newProperty: Int = this.length"
    ],
    "correctAnswer": "val String.newProperty: Int get() = this.length",
    "explanation": "Extension properties are defined similarly to extension functions but use property syntax with a getter (and optionally a setter). They cannot have backing fields.",
    "difficulty": "Hard"
  },
  {
    "question": "What is type inference in Kotlin?",
    "options": [
      "The ability to explicitly declare every variable type.",
      "The compiler's ability to automatically deduce the type of a variable or expression.",
      "A way to convert one data type to another.",
      "A feature for handling null types."
    ],
    "correctAnswer": "The compiler's ability to automatically deduce the type of a variable or expression.",
    "explanation": "Kotlin's compiler can often infer types, reducing the need for explicit type declarations, e.g., `val name = \"Kotlin\"` (type String is inferred).",
    "difficulty": "Easy"
  },
  {
    "question": "Which of the following is true for an `inline` function?",
    "options": [
      "It always runs on a separate thread.",
      "The function's bytecode is copied to every call site, potentially reducing overhead for small functions with lambda parameters.",
      "It can only be used for functions that return `Unit`.",
      "It cannot have parameters."
    ],
    "correctAnswer": "The function's bytecode is copied to every call site, potentially reducing overhead for small functions with lambda parameters.",
    "explanation": "Inlining functions, especially those taking lambdas, can reduce runtime overhead by eliminating function call costs and enabling more optimizations.",
    "difficulty": "Hard"
  },
  {
    "question": "What is a destructuring declaration in Kotlin?",
    "options": [
      "A way to declare multiple variables from the properties of an object or elements of a collection.",
      "A special declaration for destroying objects and freeing memory.",
      "A declaration used exclusively in `when` expressions.",
      "A way to declare constants that cannot be changed."
    ],
    "correctAnswer": "A way to declare multiple variables from the properties of an object or elements of a collection.",
    "explanation": "Destructuring allows you to unpack objects/collections into separate variables, e.g., `val (name, age) = person`.",
    "difficulty": "Medium"
  },
  {
    "question": "What is the `Any` type in Kotlin?",
    "options": [
      "A type that can hold any value, including null.",
      "The root of the Kotlin class hierarchy, similar to `Object` in Java.",
      "An alias for `Unit`.",
      "A marker interface for serializable objects."
    ],
    "correctAnswer": "The root of the Kotlin class hierarchy, similar to `Object` in Java.",
    "explanation": "Every class in Kotlin implicitly inherits from `Any`. It is non-nullable. `Any?` is its nullable counterpart.",
    "difficulty": "Easy"
  },
  {
    "question": "How do you specify that a function parameter can accept a variable number of arguments (varargs) of a certain type?",
    "options": [
      "params name: Type",
      "vararg name: Type",
      "args name: Type...",
      "name: Type[]"
    ],
    "correctAnswer": "vararg name: Type",
    "explanation": "The `vararg` modifier allows a function to accept a variable number of arguments for a parameter, which are then available as an array inside the function.",
    "difficulty": "Medium"
  },
  {
    "question": "What does the `suspend` keyword indicate in a Kotlin function signature?",
    "options": [
      "The function is deprecated and should not be used.",
      "The function can only be called from a Java environment.",
      "The function is an asynchronous operation that can be paused and resumed, and can only be called from a coroutine or another suspend function.",
      "The function will suspend the entire application when called."
    ],
    "correctAnswer": "The function is an asynchronous operation that can be paused and resumed, and can only be called from a coroutine or another suspend function.",
    "explanation": "`suspend` functions are the building blocks of Kotlin coroutines, allowing for non-blocking asynchronous programming.",
    "difficulty": "Medium"
  },
  {
    "question": "Which operator is used for safe casting in Kotlin, returning null if the cast is not possible?",
    "options": [
      "as",
      "is",
      "as?",
      "cast"
    ],
    "correctAnswer": "as?",
    "explanation": "The safe cast operator `as?` attempts to cast an object to a specified type and returns `null` if the cast is unsuccessful, instead of throwing a `ClassCastException`.",
    "difficulty": "Medium"
  },
  {
    "question": "What is a primary use case for type aliases in Kotlin (e.g., `typealias UserId = String`)?",
    "options": [
      "To create new distinct types.",
      "To provide alternative names for existing types, improving readability.",
      "To define generic type constraints.",
      "To enable runtime type checking."
    ],
    "correctAnswer": "To provide alternative names for existing types, improving readability.",
    "explanation": "Type aliases provide alternative names for existing types. They do not create new types but can make code more readable and maintainable.",
    "difficulty": "Medium"
  },
  {
    "question": "In Kotlin, how can a class delegate the implementation of an interface to another object?",
    "options": [
      "Using the `delegate by` keywords.",
      "Using the `implements by` keywords.",
      "Using the `via` keyword.",
      "Manual delegation by overriding all interface methods."
    ],
    "correctAnswer": "Using the `delegate by` keywords.",
    "explanation": "Kotlin supports delegation out of the box using the `by` keyword, allowing a class to delegate interface method calls to a specified object.",
    "difficulty": "Hard"
  },
  {
    "question": "What is the difference between `==` and `===` operators in Kotlin?",
    "options": [
      "`==` checks for referential equality, `===` checks for structural equality.",
      "`==` checks for structural equality (calls `equals()`), `===` checks for referential equality (checks if two references point to the same object).",
      "Both check for structural equality, but `===` is stricter.",
      "`==` is used for primitives, `===` is used for objects."
    ],
    "correctAnswer": "`==` checks for structural equality (calls `equals()`), `===` checks for referential equality (checks if two references point to the same object).",
    "explanation": "`a == b` is translated to `a?.equals(b) ?: (b === null)`, while `a === b` checks if `a` and `b` point to the exact same object in memory.",
    "difficulty": "Medium"
  },
  {
    "question": "Which scope function is similar to `run` but is an extension function and returns the context object itself, primarily used for side effects like logging or debugging?",
    "options": [
      "let",
      "apply",
      "with",
      "also"
    ],
    "correctAnswer": "also",
    "explanation": "`also` executes a given block and returns the original object. The context object is available as `it`. It's useful for performing actions that refer to the object itself rather than its properties.",
    "difficulty": "Medium"
  },
  {
    "question": "How do you achieve named arguments when calling a function in Kotlin?",
    "options": [
      "Kotlin does not support named arguments.",
      "By passing arguments in any order and the compiler figures it out.",
      "By explicitly specifying the parameter name followed by `=` and the value (e.g., `greet(name = \"Alice\", age = 30)`).",
      "Using a special annotation `@NamedArgument`."
    ],
    "correctAnswer": "By explicitly specifying the parameter name followed by `=` and the value (e.g., `greet(name = \"Alice\", age = 30)`).",
    "explanation": "Named arguments improve readability, especially for functions with many parameters or parameters of the same type. They also allow changing the order of arguments.",
    "difficulty": "Easy"
  }
]