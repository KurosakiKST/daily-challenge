[
  {
    "question": "In Swift, a struct is a value type.",
    "correctAnswer": true,
    "explanation": "Structs in Swift are value types, which means they are copied when assigned or passed as arguments, unlike classes which are reference types.",
    "difficulty": "easy"
  },
  {
    "question": "ARC (Automatic Reference Counting) manages memory automatically in Swift.",
    "correctAnswer": true,
    "explanation": "ARC automatically keeps track of strong references to class instances and deallocates memory when no longer needed.",
    "difficulty": "medium"
  },
  {
    "question": "Swift is a compiled programming language.",
    "correctAnswer": true,
    "explanation": "Swift is a compiled language that is optimized for performance and safety.",
    "difficulty": "easy"
  },
  {
    "question": "@objc attribute is always required when working with Objective-C code in Swift.",
    "correctAnswer": false,
    "explanation": "@objc is only needed when you want to expose Swift code to Objective-C or use dynamic dispatch.",
    "difficulty": "medium"
  },
  {
    "question": "Swift supports multiple inheritance of classes.",
    "correctAnswer": false,
    "explanation": "Swift does not support multiple inheritance of classes. Instead, it uses protocols and protocol extensions to achieve similar functionality.",
    "difficulty": "medium"
  },
  {
    "question": "Swift's optional chaining can prevent runtime crashes when accessing nested properties.",
    "correctAnswer": true,
    "explanation": "Optional chaining allows you to safely access properties, methods, and subscripts of an optional that might currently be nil.",
    "difficulty": "medium"
  },
  {
    "question": "Swift supports functional programming paradigms.",
    "correctAnswer": true,
    "explanation": "Swift includes many functional programming features like map, filter, reduce, and first-class functions.",
    "difficulty": "medium"
  },
  {
    "question": "In Swift, all numeric types are converted implicitly.",
    "correctAnswer": false,
    "explanation": "Swift requires explicit type conversion between different numeric types to prevent unintended precision loss.",
    "difficulty": "medium"
  },
  {
    "question": "Property observers can be added to stored properties in Swift.",
    "correctAnswer": true,
    "explanation": "willSet and didSet property observers allow you to observe and respond to changes in a property's value.",
    "difficulty": "medium"
  },
  {
    "question": "Protocol extensions can provide default implementations for protocol methods.",
    "correctAnswer": true,
    "explanation": "Swift allows adding default implementations to protocol methods through protocol extensions.",
    "difficulty": "hard"
  },
  {
    "question": "Swift's type inference always works perfectly for complex generic types.",
    "correctAnswer": false,
    "explanation": "While Swift has powerful type inference, complex generic types may require explicit type annotations.",
    "difficulty": "hard"
  },
  {
    "question": "Generics in Swift can work with any type that conforms to a specific protocol.",
    "correctAnswer": true,
    "explanation": "Swift's generics allow creating flexible, reusable code that works with types conforming to specified protocols.",
    "difficulty": "hard"
  },
  {
    "question": "Swift's type system prevents all possible runtime errors.",
    "correctAnswer": false,
    "explanation": "While Swift's type system is robust, it cannot prevent all possible runtime errors, such as those involving optionals or force unwrapping.",
    "difficulty": "hard"
  },
  {
    "question": "Closures in Swift are reference types.",
    "correctAnswer": true,
    "explanation": "Closures are reference types in Swift, which means they can create retain cycles if not handled carefully.",
    "difficulty": "hard"
  },
  {
    "question": "Swift supports multiple return values from a function using tuples.",
    "correctAnswer": true,
    "explanation": "Swift allows functions to return multiple values by packaging them in a tuple.",
    "difficulty": "easy"
  },
  {
    "question": "Optionals in Swift can only contain reference types.",
    "correctAnswer": false,
    "explanation": "Optionals in Swift can contain both value and reference types.",
    "difficulty": "medium"
  },
  {
    "question": "Swift's Result type is used for handling errors in a functional way.",
    "correctAnswer": true,
    "explanation": "The Result type provides a way to represent either a successful value or an error in a type-safe manner.",
    "difficulty": "hard"
  },
  {
    "question": "Swift supports operator overloading.",
    "correctAnswer": true,
    "explanation": "Swift allows developers to define custom implementations for standard operators for their own types.",
    "difficulty": "medium"
  },
  {
    "question": "Lazy properties are initialized only when they are first accessed.",
    "correctAnswer": true,
    "explanation": "Lazy properties defer their initialization until the first time they are accessed, which can help improve performance.",
    "difficulty": "medium"
  },
  {
    "question": "Swift's protocol-oriented programming completely replaces object-oriented programming.",
    "correctAnswer": false,
    "explanation": "Protocol-oriented programming is a powerful paradigm in Swift, but it complements rather than completely replaces object-oriented programming.",
    "difficulty": "hard"
  },
  {
    "question": "Swift's defer keyword guarantees that a block of code will always execute.",
    "correctAnswer": true,
    "explanation": "The defer keyword ensures a block of code is executed when the current scope exits, regardless of how it exits.",
    "difficulty": "hard"
  },
  {
    "question": "Type erasure is not used in Swift generics.",
    "correctAnswer": false,
    "explanation": "Type erasure is a technique used in Swift to hide the underlying type details of generic types.",
    "difficulty": "hard"
  },
  {
    "question": "Swift supports default parameter values in function definitions.",
    "correctAnswer": true,
    "explanation": "Swift allows specifying default values for function parameters, making them optional when calling the function.",
    "difficulty": "easy"
  },
  {
    "question": "Swift's @escaping closure can outlive the function it was created in.",
    "correctAnswer": true,
    "explanation": "@escaping closures can be stored and called after the function they were created in has finished executing.",
    "difficulty": "hard"
  },
  {
    "question": "Swift's where clause can be used to add constraints to generics.",
    "correctAnswer": true,
    "explanation": "The where clause allows adding specific constraints to generic type parameters.",
    "difficulty": "hard"
  },
  {
    "question": "Swift's @autoclosure can be used to delay the evaluation of an expression.",
    "correctAnswer": true,
    "explanation": "@autoclosure allows you to pass an expression that will be evaluated only when needed, which can improve performance in some cases.",
    "difficulty": "medium"
  },
  {
    "question": "Swift's typealias can create a new name for an existing type.",
    "correctAnswer": true,
    "explanation": "typealias allows you to define a new name for an existing type, improving code readability.",
    "difficulty": "easy"
  },
  {
    "question": "Swift's @discardableResult attribute is used to ignore the return value of a function.",
    "correctAnswer": true,
    "explanation": "@discardableResult allows you to call a function without using its return value, which can be useful in certain scenarios.",
    "difficulty": "medium"
  },
  {
    "question": "Swift's @dynamicCallable allows instances of a type to be called like a function.",
    "correctAnswer": true,
    "explanation": "@dynamicCallable enables types to be called as if they were functions, providing flexibility in how they can be used.",
    "difficulty": "hard"
  },
  {
    "question": "Swift's @MainActor attribute ensures that code runs on the main thread.",
    "correctAnswer": true,
    "explanation": "@MainActor ensures that the annotated code runs on the main thread, which is essential for UI updates in iOS applications.",
    "difficulty": "medium"
  },
  {
    "question": "Swift's @available attribute is used to mark deprecated APIs.",
    "correctAnswer": true,
    "explanation": "@available allows you to specify the availability of APIs, including marking them as deprecated.",
    "difficulty": "medium"
  },
  {
    "question": "Swift's @frozen attribute prevents future changes to a type's layout.",
    "correctAnswer": true,
    "explanation": "@frozen indicates that a type's layout will not change in future versions, which can improve performance in certain scenarios.",
    "difficulty": "hard"
  }
]