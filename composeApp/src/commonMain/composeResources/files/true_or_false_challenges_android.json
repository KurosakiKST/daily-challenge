[
  {
    "question": "Activities in Android are a part of the application lifecycle.",
    "correctAnswer": true,
    "explanation": "Activities represent a single screen with a UI and are essential in the lifecycle of an Android app.",
    "difficulty": "easy"
  },
  {
    "question": "An Android `Service` runs in the foreground by default.",
    "correctAnswer": false,
    "explanation": "A Service runs in the background by default unless made foreground using startForeground().",
    "difficulty": "medium"
  },
  {
    "question": "The `Manifest` file in Android declares permissions and components.",
    "correctAnswer": true,
    "explanation": "AndroidManifest.xml is used to declare essential app information and permissions.",
    "difficulty": "easy"
  },
  {
    "question": "Android `BroadcastReceiver` is used for background tasks continuously.",
    "correctAnswer": false,
    "explanation": "BroadcastReceiver is used to listen to and handle broadcast messages, not for continuous tasks.",
    "difficulty": "medium"
  },
  {
    "question": "The `WorkManager` API is suitable for guaranteed background tasks.",
    "correctAnswer": true,
    "explanation": "WorkManager is the recommended solution for deferrable, guaranteed background work.",
    "difficulty": "medium"
  },
  {
    "question": "All Android applications must have a `MainActivity`.",
    "correctAnswer": false,
    "explanation": "An Android app must have a launcher activity, not necessarily named MainActivity.",
    "difficulty": "easy"
  },
  {
    "question": "Fragments are deprecated in Jetpack libraries.",
    "correctAnswer": false,
    "explanation": "Fragments are still supported and widely used in many Android applications.",
    "difficulty": "medium"
  },
  {
    "question": "Android uses XML-based layouts in traditional UI development.",
    "correctAnswer": true,
    "explanation": "Before Jetpack Compose, Android used XML files for layout definitions.",
    "difficulty": "easy"
  },
  {
    "question": "Kotlin is fully interoperable with Java.",
    "correctAnswer": true,
    "explanation": "Kotlin can use Java libraries and vice versa without issues.",
    "difficulty": "easy"
  },
  {
    "question": "All Kotlin classes are open by default.",
    "correctAnswer": false,
    "explanation": "In Kotlin, classes are final by default and must be explicitly marked `open`.",
    "difficulty": "medium"
  },
  {
    "question": "`val` defines a mutable variable in Kotlin.",
    "correctAnswer": false,
    "explanation": "`val` defines an immutable (read-only) variable.",
    "difficulty": "easy"
  },
  {
    "question": "Kotlin supports extension functions.",
    "correctAnswer": true,
    "explanation": "Kotlin allows you to extend a class with new functionality without inheritance.",
    "difficulty": "medium"
  },
  {
    "question": "Kotlin coroutines are used for asynchronous programming.",
    "correctAnswer": true,
    "explanation": "Coroutines simplify async operations using structured concurrency.",
    "difficulty": "easy"
  },
  {
    "question": "A Kotlin `object` declaration is used to create a singleton.",
    "correctAnswer": true,
    "explanation": "The `object` keyword creates a thread-safe singleton in Kotlin.",
    "difficulty": "medium"
  },
  {
    "question": "Kotlin does not support functional programming features.",
    "correctAnswer": false,
    "explanation": "Kotlin supports many functional features like map, filter, lambdas, etc.",
    "difficulty": "easy"
  },
  {
    "question": "`lateinit` can be used with nullable types in Kotlin.",
    "correctAnswer": false,
    "explanation": "`lateinit` cannot be used with nullable types.",
    "difficulty": "hard"
  },
  {
    "question": "Jetpack Compose is the modern UI toolkit for Android.",
    "correctAnswer": true,
    "explanation": "Compose is Android\u2019s modern declarative UI toolkit.",
    "difficulty": "easy"
  },
  {
    "question": "In Compose, `@Composable` functions can return values.",
    "correctAnswer": false,
    "explanation": "`@Composable` functions are used to emit UI and should not return values.",
    "difficulty": "medium"
  },
  {
    "question": "Compose uses `remember` to maintain state across recompositions.",
    "correctAnswer": true,
    "explanation": "`remember` helps store values across recompositions.",
    "difficulty": "medium"
  },
  {
    "question": "`Modifier` in Compose is used for layout, styling, and interaction.",
    "correctAnswer": true,
    "explanation": "`Modifier` is a fundamental building block for UI elements in Compose.",
    "difficulty": "easy"
  },
  {
    "question": "Compose can interoperate with XML-based views.",
    "correctAnswer": true,
    "explanation": "Compose provides `AndroidView` for XML interoperability.",
    "difficulty": "medium"
  },
  {
    "question": "Recomposition occurs every time a Composable is called.",
    "correctAnswer": false,
    "explanation": "Recomposition only happens when observed state changes.",
    "difficulty": "hard"
  },
  {
    "question": "Compose eliminates the need for RecyclerView.",
    "correctAnswer": true,
    "explanation": "LazyColumn in Compose replaces RecyclerView in modern apps.",
    "difficulty": "easy"
  },
  {
    "question": "Kotlin Multiplatform allows sharing code between platforms like Android, iOS, and Web.",
    "correctAnswer": true,
    "explanation": "KMP promotes code reuse across multiple platforms.",
    "difficulty": "easy"
  },
  {
    "question": "Expect/Actual declarations are used in Kotlin Multiplatform for platform-specific implementations.",
    "correctAnswer": true,
    "explanation": "They allow common code to declare an API and platform code to implement it.",
    "difficulty": "medium"
  },
  {
    "question": "KMP supports UI sharing by default across platforms.",
    "correctAnswer": false,
    "explanation": "KMP mainly supports logic sharing; UI sharing is not handled directly.",
    "difficulty": "medium"
  },
  {
    "question": "KMP uses Kotlin Native to run on iOS.",
    "correctAnswer": true,
    "explanation": "Kotlin Native compiles Kotlin code to native binaries for iOS.",
    "difficulty": "medium"
  },
  {
    "question": "You can use Swift to access Kotlin shared code on iOS.",
    "correctAnswer": true,
    "explanation": "Kotlin Native exposes a framework that Swift can use.",
    "difficulty": "medium"
  },
  {
    "question": "Kotlin Multiplatform cannot be used in production apps.",
    "correctAnswer": false,
    "explanation": "Many companies use KMP in production successfully.",
    "difficulty": "easy"
  },
  {
    "question": "KMP projects require completely different build setups for each platform.",
    "correctAnswer": false,
    "explanation": "KMP uses a unified Gradle setup to build for multiple targets.",
    "difficulty": "medium"
  },
  {
    "question": "In Android, `ViewModel` is destroyed when the screen is rotated.",
    "correctAnswer": false,
    "explanation": "`ViewModel` survives configuration changes like screen rotation.",
    "difficulty": "easy"
  },
  {
    "question": "Jetpack Compose is a declarative UI toolkit for building Android apps.",
    "correctAnswer": true,
    "explanation": "Jetpack Compose allows you to describe your UI using composable functions.",
    "difficulty": "easy"
  },
  {
    "question": "An `Activity` in Android can exist without a `Context`.",
    "correctAnswer": false,
    "explanation": "All `Activity` instances require a `Context` to function properly.",
    "difficulty": "medium"
  },
  {
    "question": "`LiveData` is lifecycle-aware and updates only when the observer is active.",
    "correctAnswer": true,
    "explanation": "`LiveData` only sends updates to observers in active lifecycle states.",
    "difficulty": "medium"
  },
  {
    "question": "In Android, all UI updates must happen on a background thread.",
    "correctAnswer": false,
    "explanation": "UI updates must happen on the **main (UI)** thread, not a background thread.",
    "difficulty": "easy"
  },
  {
    "question": "Kotlin Coroutines can be used for asynchronous programming in Android.",
    "correctAnswer": true,
    "explanation": "Coroutines simplify asynchronous tasks by using structured concurrency.",
    "difficulty": "medium"
  },
  {
    "question": "The `onCreate()` method is called after `onStart()` in an Activity lifecycle.",
    "correctAnswer": false,
    "explanation": "`onCreate()` is called before `onStart()` when the activity is first created.",
    "difficulty": "easy"
  },
  {
    "question": "Room is an object-mapping library for SQLite databases in Android.",
    "correctAnswer": true,
    "explanation": "Room provides an abstraction layer over SQLite for easier database access.",
    "difficulty": "medium"
  },
  {
    "question": "Fragments can be added to an Activity using `FragmentManager`.",
    "correctAnswer": true,
    "explanation": "`FragmentManager` allows you to perform fragment transactions in an Activity.",
    "difficulty": "easy"
  },
  {
    "question": "Android applications cannot run background tasks after API 26.",
    "correctAnswer": false,
    "explanation": "Background tasks are still possible after API 26, but with stricter limitations (e.g., using `WorkManager`).",
    "difficulty": "hard"
  },
  {
    "question": "Using `GlobalScope` for launching coroutines in Android is recommended for UI-related tasks.",
    "correctAnswer": false,
    "explanation": "`GlobalScope` lives for the entire application lifecycle and is not lifecycle-aware, making it unsafe for UI operations.",
    "difficulty": "hard"
  },
  {
    "question": "Kotlin coroutines launched in `GlobalScope` are automatically canceled when the `Activity` is destroyed.",
    "correctAnswer": false,
    "explanation": "`GlobalScope` coroutines are not tied to any lifecycle and must be manually canceled to avoid memory leaks.",
    "difficulty": "hard"
  },
  {
    "question": "`SharedFlow` will automatically re-emit the last value to new subscribers by default.",
    "correctAnswer": false,
    "explanation": "`SharedFlow` does not retain values unless a replay cache is explicitly defined.",
    "difficulty": "hard"
  },
  {
    "question": "`StateFlow` requires an initial value upon creation.",
    "correctAnswer": true,
    "explanation": "`StateFlow` is a state-holder and always requires an initial value to emit.",
    "difficulty": "hard"
  },
  {
    "question": "Jetpack Compose's `LaunchedEffect` runs every time recomposition occurs regardless of its key.",
    "correctAnswer": false,
    "explanation": "`LaunchedEffect` only re-runs when the provided key(s) change.",
    "difficulty": "hard"
  },
  {
    "question": "You can use `suspend` functions directly inside `@Composable` functions.",
    "correctAnswer": false,
    "explanation": "`@Composable` functions cannot call `suspend` functions directly. Use `LaunchedEffect` or coroutine scopes inside Compose.",
    "difficulty": "hard"
  },
  {
    "question": "Using `remember` inside a `@Composable` prevents recomposition when values change.",
    "correctAnswer": false,
    "explanation": "`remember` retains the value across recompositions but doesn't prevent recomposition itself.",
    "difficulty": "hard"
  },
  {
    "question": "`collectAsState()` can be used to observe a `StateFlow` in Compose and trigger recompositions.",
    "correctAnswer": true,
    "explanation": "`collectAsState()` bridges StateFlow and Compose by observing the flow and triggering recomposition.",
    "difficulty": "hard"
  },
  {
    "question": "The Android Runtime (ART) uses Just-In-Time (JIT) and Ahead-Of-Time (AOT) compilation strategies.",
    "correctAnswer": true,
    "explanation": "ART uses both JIT (during runtime) and AOT (during install) to improve performance and reduce startup time.",
    "difficulty": "hard"
  },
  {
    "question": "ViewModel's `viewModelScope` gets automatically cancelled when the associated `Activity` is destroyed.",
    "correctAnswer": false,
    "explanation": "`viewModelScope` is tied to the `ViewModel`, not the `Activity`. It is only cleared when the ViewModel is cleared.",
    "difficulty": "hard"
  }
]